--- gd.c.orig	Fri Mar 13 23:29:28 1998
+++ gd.c	Wed Apr  7 01:10:42 1999
@@ -2445,9 +2445,9 @@
 {
 	int i;
 	int y;
-	int y1, y2;
+	int ymin, ymax;
 	int ints;
-	if (!n) {
+	if (n < 1) {
 		return;
 	}
 	if (!im->polyAllocated) {
@@ -2461,92 +2461,43 @@
 		im->polyInts = (int *) realloc(im->polyInts,
 			sizeof(int) * im->polyAllocated);
 	}
-	y1 = p[0].y;
-	y2 = p[0].y;
+	ymin = p[0].y;
+	ymax = p[0].y;
 	for (i=1; (i < n); i++) {
-		if (p[i].y < y1) {
-			y1 = p[i].y;
+		if (p[i].y < ymin) {
+			ymin = p[i].y;
 		}
-		if (p[i].y > y2) {
-			y2 = p[i].y;
+		if (p[i].y > ymax) {
+			ymax = p[i].y;
 		}
 	}
-	/* Fix in 1.3: count a vertex only once */
-	for (y=y1; (y < y2); y++) {
-		int interLast = 0;
-		int dirLast = 0;
-		int interFirst = 1;
+	for (y=ymin; (y < ymax); y++) {
 		ints = 0;
-		for (i=0; (i <= n); i++) {
+		for (i=0; (i < n); i++) {
 			int x1, x2;
 			int y1, y2;
-			int dir;
 			int ind1, ind2;
-			int lastInd1 = 0;
-			if ((i == n) || (!i)) {
-				ind1 = n-1;
-				ind2 = 0;
-			} else {
-				ind1 = i-1;
-				ind2 = i;
-			}
+			ind1 = i;
+			ind2 = (i + 1) % n;
 			y1 = p[ind1].y;
 			y2 = p[ind2].y;
-			if (y1 < y2) {
-				y1 = p[ind1].y;
-				y2 = p[ind2].y;
-				x1 = p[ind1].x;
-				x2 = p[ind2].x;
-				dir = -1;
-			} else if (y1 > y2) {
-				y2 = p[ind1].y;
-				y1 = p[ind2].y;
-				x2 = p[ind1].x;
-				x1 = p[ind2].x;
-				dir = 1;
-			} else {
-				/* Horizontal; just draw it */
-				gdImageLine(im, 
-					p[ind1].x, y1, 
-					p[ind2].x, y1,
-					c);
-				continue;
-			}
-			if ((y >= y1) && (y <= y2)) {
-				int inter = 
-					(y-y1) * (x2-x1) / (y2-y1) + x1;
-				/* Only count intersections once
-					except at maxima and minima. Also, 
-					if two consecutive intersections are
-					endpoints of the same horizontal line
-					that is not at a maxima or minima,	
-					discard the leftmost of the two. */
-				if (!interFirst) {
-					if ((p[ind1].y == p[lastInd1].y) &&
-						(p[ind1].x != p[lastInd1].x)) {
-						if (dir == dirLast) {
-							if (inter > interLast) {
-								/* Replace the old one */
-								im->polyInts[ints] = inter;
-							} else {
-								/* Discard this one */
-							}	
-							continue;
-						}
+			x1 = p[ind1].x;
+			x2 = p[ind2].x;
+			/* intersection exists only if y is between y1 and y2 */
+			if ((y >= y1) && (y <= y2) || (y >= y2) && (y <= y1)) {
+				if (y1 == y2) {
+					/* horizontal edge - just draw it */
+					gdImageLine(im, x1, y, x2, y, c);
+				} else {
+					if ((y == y1 && y1 < y2) || (y == y2 && y2 < y1)) {
+						/* intersecting at min of an edge, ignore 
+						   to avoid double counting! */
+					} else {
+						/* OK, this one we do want to count :) */
+						int inter = (y-y1) * (x2-x1) / (y2-y1) + x1;
+						im->polyInts[ints++] = inter;
 					}
-					if (inter == interLast) {
-						if (dir == dirLast) {
-							continue;
-						}
-					}
-				} 
-				if (i > 0) {
-					im->polyInts[ints++] = inter;
 				}
-				lastInd1 = i;
-				dirLast = dir;
-				interLast = inter;
-				interFirst = 0;
 			}
 		}
 		qsort(im->polyInts, ints, sizeof(int), gdCompareInt);
